{
	"id": "67710d7c54eaefce9608928d53d503a4",
	"_format": "hh-sol-build-info-1",
	"solcVersion": "0.8.7",
	"solcLongVersion": "0.8.7+commit.e28d00a7",
	"input": {
		"language": "Solidity",
		"sources": {
			"contracts/Pair.sol": {
				"content": "// //SPDX-License-Identifier: MIT\r\n// pragma solidity ^0.8.7;\r\n\r\n// // Pair contract is essentially ERC20 and IERC20 is the interface contract \r\n// // that will be used to interact with other ERC20 contracts if need be\r\n// import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n// import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n\r\n// // This interface is added to be able to interact with other exchanges \r\n// // It allows us to call the functions listed\r\n// interface IPair{\r\n\r\n//     //Defined as external payable to allow the function to accept value\r\n//     function ethToTokenSwap(uint256 expectedTokenAmount) external payable;\r\n//     function ethToTokenTransfer(uint256 expectedTokenAmount, address recipient) external payable;\r\n// }\r\n\r\n// interface IFactory {\r\n//     function getExchange(address tokenAddress) external returns (address);\r\n// }\r\n\r\n// contract Pair is ERC20 {\r\n//     address public tokenAddress;\r\n//     address public factoryAddress;\r\n\r\n//     // The indexed keyword allows us to search for these events using indexed parameters as filters\r\n//     event SwapForTokens(address indexed buyer, uint256 indexed ethGiven, uint256 tokensRecieved);\r\n//     event SwapForEth(address indexed buyer, uint256 indexed tokensGiven, uint256 ethRecieved);\r\n//     event AddLiquidity(\r\n//         address indexed provider,\r\n//         uint256 indexed ethAmount,\r\n//         uint256 indexed tokenAmount\r\n//     );\r\n//     event RemoveLiquidity(\r\n//         address indexed provider,\r\n//         uint256 indexed ethAmount,\r\n//         uint256 indexed tokenAmount\r\n//     );\r\n\r\n//     uint constant txFee = 0;\r\n\r\n//     // constructor takes in a parameter for the address of the token, for this pair contract\r\n//     constructor(address token) ERC20(\"Swap V1\", \"Swap-V1\"){\r\n//         require(token != address(0), \"Invalid address\");\r\n//         tokenAddress = token;\r\n//         factoryAddress = msg.sender;\r\n//     }\r\n\r\n//     function getReserves() public view returns (uint256 tokenReserve, uint256 ethReserve) {\r\n//         tokenReserve = IERC20(tokenAddress).balanceOf(address(this));\r\n//         ethReserve = address(this).balance;\r\n//     }\r\n\r\n//     function addLiquidity(uint256 inputTokenAmount ) public payable returns (uint256 lpTokenAmount){\r\n//         (uint256 tokenReserve, uint256 ethReserve) = getReserves();\r\n\r\n//         // uint256 requiredTokenInput = msg.value * tokenReserve/ethReserve; //calculate the amount of tokenInput required to ensure the ratio is the same\r\n        \r\n//         //New liquidity pool\r\n//         if (tokenReserve == 0) {\r\n//             IERC20 token = IERC20(tokenAddress);\r\n//             token.transferFrom(msg.sender, address(this), inputTokenAmount);\r\n//             lpTokenAmount = ethReserve; \r\n//         }\r\n//         //Existing liquidity pool\r\n//         else{\r\n//             ethReserve -= msg.value; //This is done as the msg.value has already been added to the ethReserve\r\n//             uint256 requiredTokenInput = msg.value * tokenReserve/ethReserve; //calculate the amount of tokenInput required to ensure the ratio is the same\r\n//             require(inputTokenAmount >= requiredTokenInput, \"Insufficient input amount of ERC20 Tokens\");\r\n//             IERC20 token = IERC20(tokenAddress);\r\n//             token.transferFrom(msg.sender, address(this), inputTokenAmount);\r\n//             lpTokenAmount = (totalSupply() * msg.value) / ethReserve;\r\n//         }\r\n\r\n//         _mint(msg.sender, lpTokenAmount);\r\n//         emit AddLiquidity(msg.sender, msg.value, inputTokenAmount);\r\n//     }\r\n\r\n//     function removeLiquidity(uint256 lpTokenAmount) public returns (uint256 ethAmount, uint256 tokenAmount){\r\n//         require(lpTokenAmount > 0, \"Please input a valid amount of LP Tokens to burn/redeem\");\r\n\r\n//         (uint256 tokenReserve, uint256 ethReserve) = getReserves();\r\n//         ethAmount = (ethReserve * lpTokenAmount) / totalSupply();\r\n//         tokenAmount = (tokenReserve * lpTokenAmount) / totalSupply();\r\n\r\n//         _burn(msg.sender, lpTokenAmount);\r\n//         (bool sent, ) = (msg.sender).call{value: ethAmount}(\"\");\r\n//         require(sent, \"Transaction of Ether was unsuccessful\");\r\n//         IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\r\n//         emit RemoveLiquidity(msg.sender, ethAmount, tokenAmount);\r\n//     }\r\n\r\n//     function getOutputAmount(uint256 ipAmount, uint256 ipReserve, uint256 opReserve) private pure returns (uint256 opAmount) {\r\n//         require(ipReserve > 0 && opReserve > 0, \"There are no reserves\");\r\n//         uint256 ipAmountPlusFee = ipAmount * (1000 - txFee);\r\n//         opAmount = ipAmountPlusFee * opReserve / (1000 * ipReserve + ipAmountPlusFee);\r\n//     }\r\n\r\n//     //Use this function to get the exchange amount\r\n//     function getTokenAmountForSwap(uint256 ethAmount) public view returns (uint256 tokenAmount){\r\n//         require(ethAmount > 0, \"ETH amount cannot be zero\");\r\n\r\n//         (uint256 tokenReserve, uint256 ethReserve) = getReserves();\r\n//         //Amount of ETH in exchange for tokens\r\n//         tokenAmount = getOutputAmount(ethAmount, ethReserve, tokenReserve);\r\n//     }\r\n\r\n//     //Use this function to get the exchange amount\r\n//     function getEthAmountForSwap(uint256 tokenAmount) public view returns (uint256 ethAmount){\r\n//         require(ethAmount > 0, \"ETH amount cannot be zero\");\r\n\r\n//         (uint256 tokenReserve, uint256 ethReserve) = getReserves();\r\n//         //Amount of ETH in exchange for tokens\r\n//         ethAmount = getOutputAmount(tokenAmount, tokenReserve, ethReserve);\r\n//     }\r\n\r\n//     //Base function to be called by other functions\r\n//     function ethForTokenBasic(uint256 tokenAmount, address recipient) private {\r\n//         (uint256 tokenReserve, uint256 ethReserve) = getReserves();\r\n//         uint256 tokensRecieved = getOutputAmount(msg.value, ethReserve - msg.value, tokenReserve);\r\n\r\n//         require(tokensRecieved >= tokenAmount, \"Amount swapped does not meet your stipulated amount, reverting swap\");\r\n\r\n//         IERC20(tokenAddress).transfer(recipient, tokensRecieved);\r\n//         emit SwapForTokens(recipient, msg.value, tokensRecieved);\r\n//     }\r\n\r\n//     //Can be used to swap for oneself and also to maybe swap and pay others\r\n//     function ethToTokenTransfer(uint256 tokenAmount, address recipient) public payable{\r\n//         ethForTokenBasic(tokenAmount, recipient);\r\n//     }\r\n\r\n//     //used for implicit calling\r\n//     function ethToTokenSwap(uint256 tokenAmount) public payable {\r\n//         ethForTokenBasic(tokenAmount, msg.sender);\r\n//     }\r\n\r\n//     //\r\n//     function tokenForEthSwap(uint256 ipTokenAmount, uint256 opEthAmount) public {\r\n//         (uint256 tokenReserve, uint256 ethReserve) = getReserves();\r\n\r\n//         uint256 ethRecieved = getOutputAmount(ipTokenAmount, tokenReserve, ethReserve);\r\n\r\n//         require(ethRecieved >= opEthAmount, \"Amount swapped does not meet your stipulated amount, reverting swap\");\r\n//         IERC20(tokenAddress).transferFrom(msg.sender, address(this), ipTokenAmount);\r\n//         (bool sent, ) = (msg.sender).call{value: opEthAmount}(\"\");\r\n//         require(sent, \"Transaction of ETH to recipient failed\");\r\n//         emit SwapForEth(msg.sender, ipTokenAmount, ethRecieved);\r\n//     }\r\n\r\n\r\n//     function tokenToTokenSwap(uint256 ipTokenAmount, uint256 opTokenAmount, address opTokenAddress) public {\r\n//         require(opTokenAddress != address(0), \"Token address is invalid\");\r\n//         require(ipTokenAmount > 0, \"Invalid input token amount\");\r\n//         address opTokenExchangeAddress = IFactory(factoryAddress).getExchange(opTokenAddress);\r\n\r\n//         require(opTokenExchangeAddress != address(this) && opTokenExchangeAddress != address(0),\"Invalid exchange address\");\r\n\r\n//         (uint256 tokenReserve, uint256 ethReserve) = getReserves();\r\n        \r\n//         uint256 ethAmount = getOutputAmount(ipTokenAmount, tokenReserve, ethReserve);\r\n//         IERC20(tokenAddress).transferFrom(msg.sender, address(this), ipTokenAmount);\r\n//         IPair(opTokenExchangeAddress).ethToTokenTransfer{value: ethAmount}(opTokenAmount, msg.sender);\r\n\r\n//     }\r\n\r\n\r\n\r\n\r\n// }\r\n\r\n\r\n// pragma solidity ^0.8.7;\r\n\r\n// import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n// import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n// /**\r\n//  * THIS IS AN EXAMPLE CONTRACT WHICH IS NOT AUDITED\r\n//  * PLEASE DO NOT USE THIS CODE IN PRODUCTION.\r\n//  */\r\n\r\n// interface IPair {\r\n//     function ethToTokenSwap(uint256 expectedTokenAmount) external payable;\r\n\r\n//     function ethToTokenTransfer(uint256 expectedTokenAmount, address recipient) external payable;\r\n// }\r\n\r\n// interface IFactory {\r\n//     function getPair(address tokenAddress) external returns (address);\r\n// }\r\n\r\n// contract Pair is ERC20 {\r\n//     address public tokenAddress;\r\n//     address public factoryAddress;\r\n\r\n//     // events\r\n//     event TokenPurchase(address indexed buyer, uint256 indexed ethSold, uint256 tokenBought);\r\n//     event EthPurchase(address indexed buyer, uint256 indexed tokenSold, uint256 ethBought);\r\n//     event AddLiquidity(\r\n//         address indexed provider,\r\n//         uint256 indexed ethAmount,\r\n//         uint256 indexed tokenAmount\r\n//     );\r\n//     event RemoveLiquidity(\r\n//         address indexed provider,\r\n//         uint256 indexed ethAmount,\r\n//         uint256 indexed tokenAmount\r\n//     );\r\n\r\n//     //fee as per thousandth \r\n//     uint constant fee = 0;\r\n\r\n//     constructor(address token) ERC20(\"Fikaswap V1\", \"Fika-V1\") {\r\n//         require(token != address(0), \"invalid token address\");\r\n//         tokenAddress = token;\r\n//         factoryAddress = msg.sender;\r\n//     }\r\n\r\n//     /**\r\n//      * Called by liquidity providers. Must provide the same value of `tokenAmount` as `msg.value` in order to respect the current reserve ratio\r\n//      * reserve formula to respect: (tokenAmount/msg.value) = (tokenReserve/ethReserve)\r\n//      * @param tokenAmount uint256: input amount of token that liquidity provider is depositing\r\n//      * @return poolTokenAmount uint256: amount of pool token rewarded to the liquidity provider\r\n//      * @notice payable modifier: expect to receive `msg.value` ETH\r\n//      * @notice at initialization (when `tokenReserve` ==0) , allow the 1st liquidity provider to decide on the initial reserve ratio\r\n//      * @notice check that the liquidity provider has provided enough `tokenAmount` and take only what's needed (`expectedTokenAmount`)\r\n//      * @notice reward liquidity provider with pool tokens. Amount of tokens is proportional to the amout of eth provided comparatively to the total ETH reserve.\r\n//      */\r\n//     function addLiquidity(uint256 tokenAmount) public payable returns (uint256 poolTokenAmount) {\r\n//         // Retrieve reserves\r\n//         (uint256 tokenReserve, uint256 ethReserve) = getReserves();\r\n//         if (tokenReserve == 0) {\r\n//             // at initialization of the exchange, we accept whatever the 1st liquidity provider has given us\r\n//             IERC20 token = IERC20(tokenAddress);\r\n//             token.transferFrom(msg.sender, address(this), tokenAmount);\r\n//             // at initialization , pool token amount is equal to the amount of ethers\r\n//             poolTokenAmount = ethReserve;\r\n//         } else {\r\n//             // Substract msg.value from the balance before calculating reserve\r\n//             ethReserve = ethReserve - msg.value;\r\n//             // expected amount based on the current reserve ratio tokenReserve / ethReserve\r\n//             uint256 expectedtokenAmount = (msg.value * tokenReserve) / ethReserve;\r\n//             require(tokenAmount >= expectedtokenAmount, \"Insufficient token amount\");\r\n//             IERC20 token = IERC20(tokenAddress);\r\n//             token.transferFrom(msg.sender, address(this), expectedtokenAmount);\r\n//             // pool token amount based on ratio providedEth/ethReserve\r\n//             // (poolTokenAmount/totalPoolTokenSupply) = (depositedEth/ethReserve)\r\n//             poolTokenAmount = (totalSupply() * msg.value) / ethReserve;\r\n//         }\r\n//         // reward the liquidity provider with calculated pool tokens amount\r\n//         _mint(msg.sender, poolTokenAmount);\r\n//         emit AddLiquidity(msg.sender, msg.value, tokenAmount);\r\n//     }\r\n\r\n//     /**\r\n//      * Called by liquidity providers. Burn pool tokens in exchange of ETH & Tokens at current ratios.\r\n//      *\r\n//      * @param poolTokenAmount uint256: Amount of pool token to be burned\r\n//      * @return ethAmount uint256: Amount of ETH withdrawn\r\n//      * @return tokenAmount uint256: Amount of Tokens withdrawn\r\n//      */\r\n//     function removeLiquidity(uint256 poolTokenAmount)\r\n//         public\r\n//         returns (uint256 ethAmount, uint256 tokenAmount)\r\n//     {\r\n//         require(poolTokenAmount > 0, \"Amount of pool token cannot be 0\");\r\n//         // Retrieve reserves\r\n//         (uint256 tokenReserve, uint256 ethReserve) = getReserves();\r\n\r\n//         // calculate the amount of Token & ETH based on the ratio\r\n//         ethAmount = (ethReserve * poolTokenAmount) / totalSupply();\r\n//         tokenAmount = (tokenReserve * poolTokenAmount) / totalSupply();\r\n\r\n//         // reduce supply of pool tokens\r\n//         _burn(msg.sender, poolTokenAmount);\r\n//         // returns ETH & Token to the liquidity provider\r\n//         (bool sent, ) = (msg.sender).call{value: ethAmount}(\"\");\r\n//         require(sent, \"Failed to send Ether\");\r\n//         IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\r\n//         emit RemoveLiquidity(msg.sender, ethAmount, tokenAmount);\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Pricing function `outputAmount` of token2 if we provide `inputAmount` of token1 in exchange.\r\n//      *\r\n//      * @param inputAmount uint256: Amount of token1 we are selling\r\n//      * @param inputReserve uint256: Reserve of token1 we are selling\r\n//      * @param outputReserve uint256: Reserve of token2 we are buying\r\n//      * @return outputAmount uint256: Amount of token2 we receive in exchange\r\n//      *\r\n//      * @notice fees taken intout account. 0,3 % fees . 0,3 % = 3/1000. Fees removed from `inputAmount`\r\n//      */\r\n//     function getAmount(\r\n//         uint256 inputAmount,\r\n//         uint256 inputReserve,\r\n//         uint256 outputReserve\r\n//     ) private pure returns (uint256 outputAmount) {\r\n//         require(inputReserve > 0 && outputReserve > 0, \"Reserves cannot be null\");\r\n//         uint256 inputAmountWithFee = inputAmount * (1000 - fee);\r\n//         uint256 numerator = inputAmountWithFee * outputReserve;\r\n//         uint256 denominator = (1000 * inputReserve + inputAmountWithFee);\r\n\r\n//         outputAmount = numerator / denominator;\r\n//     }\r\n\r\n//     /**\r\n//      * Get `tokenAmount` if we provide `ethAmount` in exchange.\r\n//      *\r\n//      * @param ethAmount uint256: Amount of ETH we are selling\r\n//      * @return tokenAmount uint256: Amount of Token we receive in exchange\r\n//      */\r\n//     function getTokenAmount(uint256 ethAmount) public view returns (uint256 tokenAmount) {\r\n//         require(ethAmount > 0, \"Eth amount cannot be null\");\r\n\r\n//         // Retrieve reserves\r\n//         // Retrieve reserves\r\n//         (uint256 tokenReserve, uint256 ethReserve) = getReserves();\r\n\r\n//         // Trading ethAmount for tokenAmount (= Buy Token with Eth)\r\n//         tokenAmount = getAmount(ethAmount, ethReserve, tokenReserve);\r\n//     }\r\n\r\n//     /**\r\n//      * Get `ethAmount` if we provide `tokenAmount` in exchange.\r\n//      *\r\n//      * @param tokenAmount uint256: Amount of Token we are selling\r\n//      * @return ethAmount uint256: Amount of ETH we receive in exchange\r\n//      */\r\n//     function getEthAmount(uint256 tokenAmount) public view returns (uint256 ethAmount) {\r\n//         require(tokenAmount > 0, \"Token amount cannot be null\");\r\n\r\n//         // Retrieve reserves\r\n//         (uint256 tokenReserve, uint256 ethReserve) = getReserves();\r\n\r\n//         // Trading tokenAmount for ethAmount (= Sell Token for Eth)\r\n//         ethAmount = getAmount(tokenAmount, tokenReserve, ethReserve);\r\n//     }\r\n\r\n//     /**\r\n//      * Buy `expectedTokenAmount` in exchange of at least `msg.value` ETH\r\n//      *\r\n//      * @notice Protect users from front-running bots but asking them to provide `expectedTokenAmount`\r\n//      *\r\n//      * @param expectedTokenAmount uint256: Expected amount of token to be received by the user\r\n//      * @param recipient address: Recipient address\r\n//      */\r\n//     function ethToToken(uint256 expectedTokenAmount, address recipient) private {\r\n//         // Retrieve reserves\r\n//         (uint256 tokenReserve, uint256 ethReserve) = getReserves();\r\n\r\n//         uint256 tokenAmount = getAmount(msg.value, ethReserve - msg.value, tokenReserve);\r\n\r\n//         require(tokenAmount >= expectedTokenAmount, \"Token Amount low\");\r\n\r\n//         IERC20(tokenAddress).transfer(recipient, tokenAmount);\r\n//         emit TokenPurchase(recipient, msg.value, tokenAmount);\r\n//     }\r\n\r\n//     /**\r\n//      * Buy `expectedTokenAmount` in exchange of at least `msg.value` ETH\r\n//      *\r\n//      * @notice Because the function receives ETH , `msg.value` has been added to the ETH reserve. Hence, we need to subsctract it before calling the `getAmount` function\r\n//      * @notice Protect users from front-running bots but asking them to provide `expectedTokenAmount`\r\n//      *\r\n//      * @param expectedTokenAmount uint256: Expected amount of token to be received by the user\r\n//      * @param recipient address: Recipient address\r\n//      */\r\n//     function ethToTokenTransfer(uint256 expectedTokenAmount, address recipient) public payable {\r\n//         ethToToken(expectedTokenAmount, recipient);\r\n//     }\r\n\r\n//     /**\r\n//      * Buy `expectedTokenAmount` in exchange of at least `msg.value` ETH\r\n//      *\r\n//      * @notice Because the function receives ETH , `msg.value` has been added to the ETH reserve. Hence, we need to subsctract it before calling the `getAmount` function\r\n//      * @notice Protect users from front-running bots but asking them to provide `expectedTokenAmount`\r\n//      *\r\n//      * @param expectedTokenAmount uint256: Expected amount of token to be received by the user\r\n//      * @dev Calls `ethToToken()` . recipient is `msg.sender`\r\n//      */\r\n//     function ethToTokenSwap(uint256 expectedTokenAmount) public payable {\r\n//         ethToToken(expectedTokenAmount, msg.sender);\r\n//     }\r\n\r\n//     /**\r\n//      * Sell `tokenAmount` in exchange of at least `expectedEthAmount` ETH\r\n//      *\r\n//      * @notice Protect users from front-running bots but asking them to provide `expectedTokenAmount`\r\n//      *\r\n//      * @param tokenAmount uint256: Amount of Token sold to the Exchange\r\n//      * @param expectedEthAmount uint256: Expected amount of ETH to be received by the user\r\n//      */\r\n//     function tokenToEthSwap(uint256 tokenAmount, uint256 expectedEthAmount) public {\r\n//         // Retrieve reserves\r\n//         (uint256 tokenReserve, uint256 ethReserve) = getReserves();\r\n\r\n//         uint256 ethAmount = getAmount(tokenAmount, tokenReserve, ethReserve);\r\n\r\n//         require(ethAmount >= expectedEthAmount, \"Eth Amount low\");\r\n\r\n//         IERC20(tokenAddress).transferFrom(msg.sender, address(this), tokenAmount);\r\n//         (bool sent, ) = (msg.sender).call{value: ethAmount}(\"\");\r\n//         require(sent, \"Failed to send Ether\");\r\n//         emit EthPurchase(msg.sender, tokenAmount, ethAmount);\r\n//     }\r\n\r\n//     /**\r\n//      * Sell `tokenAmount` in exchange for at least `expectedTargetTokenAmount` of target Token\r\n//      *\r\n//      * @dev ETH uses as a bridge. Token --> ETH --> Target Token\r\n//      *\r\n//      * @param tokenAmount uint256: Amount of Token sold to the Exchange\r\n//      * @param expectedTargetTokenAmount uint256: Expected amount of Target token to be received by the user\r\n//      * @param targetTokenAddress address: Target Token address\r\n//      */\r\n//     function tokenToTokenSwap(\r\n//         uint256 tokenAmount,\r\n//         uint256 expectedTargetTokenAmount,\r\n//         address targetTokenAddress\r\n//     ) public {\r\n//         require(targetTokenAddress != address(0), \"Token address not valid\");\r\n//         require(tokenAmount > 0, \"Tokens amount not valid\");\r\n//         address targetExchangeAddress = IFactory(factoryAddress).getPair(targetTokenAddress);\r\n//         require(\r\n//             targetExchangeAddress != address(this) && targetExchangeAddress != address(0),\r\n//             \"Exchange address not valid\"\r\n//         );\r\n\r\n//         // Retrieve reserves\r\n//         (uint256 tokenReserve, uint256 ethReserve) = getReserves();\r\n//         uint256 ethAmount = getAmount(tokenAmount, tokenReserve, ethReserve);\r\n\r\n//         IERC20(tokenAddress).transferFrom(msg.sender, address(this), tokenAmount);\r\n\r\n//         IPair(targetExchangeAddress).ethToTokenTransfer{value: ethAmount}(\r\n//             expectedTargetTokenAmount,\r\n//             msg.sender\r\n//         );\r\n//     }\r\n\r\n//     /**\r\n//      * Return reserves of Token & ETH within the exchange\r\n//      * @return tokenReserve uint256 : Exchange Token Balance\r\n//      * @return ethReserve uint256: Exchange ETH Balance\r\n//      */\r\n//     function getReserves() public view returns (uint256 tokenReserve, uint256 ethReserve) {\r\n//         // Retrieve reserves\r\n//         tokenReserve = IERC20(tokenAddress).balanceOf(address(this));\r\n//         ethReserve = address(this).balance;\r\n//     }\r\n// }\r\n"
			}
		},
		"settings": {
			"optimizer": {
				"enabled": false,
				"runs": 200
			},
			"outputSelection": {
				"*": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"metadata",
						"devdoc",
						"userdoc",
						"storageLayout",
						"evm.legacyAssembly",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"evm.gasEstimates",
						"evm.assembly"
					]
				}
			}
		}
	},
	"output": {
		"errors": [
			{
				"component": "general",
				"errorCode": "3420",
				"formattedMessage": "Warning: Source file does not specify required compiler version! Consider adding \"pragma solidity ^0.8.7;\"\n--> contracts/Pair.sol\n\n",
				"message": "Source file does not specify required compiler version! Consider adding \"pragma solidity ^0.8.7;\"",
				"severity": "warning",
				"sourceLocation": {
					"end": -1,
					"file": "contracts/Pair.sol",
					"start": -1
				},
				"type": "Warning"
			}
		],
		"sources": {
			"contracts/Pair.sol": {
				"ast": {
					"absolutePath": "contracts/Pair.sol",
					"exportedSymbols": {},
					"id": 1,
					"license": "MIT",
					"nodeType": "SourceUnit",
					"nodes": [],
					"src": "21526:0:0"
				},
				"id": 0
			}
		}
	}
}